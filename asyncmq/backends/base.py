from abc import ABC, abstractmethod
from typing import Any, List, Optional


class BaseBackend(ABC):
    # Core queue operations
    @abstractmethod
    async def enqueue(self, queue_name: str, payload: dict): ...

    @abstractmethod
    async def dequeue(self, queue_name: str) -> Optional[dict]: ...

    @abstractmethod
    async def move_to_dlq(self, queue_name: str, payload: dict): ...

    @abstractmethod
    async def ack(self, queue_name: str, job_id: str): ...

    @abstractmethod
    async def enqueue_delayed(self, queue_name: str, payload: dict, run_at: float): ...

    @abstractmethod
    async def get_due_delayed(self, queue_name: str) -> List[dict]: ...

    @abstractmethod
    async def remove_delayed(self, queue_name: str, job_id: str): ...

    @abstractmethod
    async def update_job_state(self, queue_name: str, job_id: str, state: str): ...

    @abstractmethod
    async def save_job_result(self, queue_name: str, job_id: str, result: Any): ...

    @abstractmethod
    async def get_job_state(self, queue_name: str, job_id: str) -> Optional[str]: ...

    @abstractmethod
    async def get_job_result(self, queue_name: str, job_id: str) -> Optional[Any]: ...

    # Advanced, backend-agnostic features
    @abstractmethod
    async def add_dependencies(self, queue_name: str, job_dict: dict): ...

    @abstractmethod
    async def resolve_dependency(self, queue_name: str, parent_id: str): ...

    @abstractmethod
    async def pause_queue(self, queue_name: str): ...

    @abstractmethod
    async def resume_queue(self, queue_name: str): ...

    @abstractmethod
    async def is_queue_paused(self, queue_name: str) -> bool: ...

    @abstractmethod
    async def save_job_progress(self, queue_name: str, job_id: str, progress: float): ...

    @abstractmethod
    async def bulk_enqueue(self, queue_name: str, jobs: List[dict]): ...

    @abstractmethod
    async def purge(self, queue_name: str, state: str, older_than: Optional[float] = None): ...

    @abstractmethod
    async def emit_event(self, event: str, data: dict): ...

    @abstractmethod
    async def create_lock(self, key: str, ttl: int): ...
