import json
from typing import Any, Dict, List, Optional

import redis.asyncio as redis

from asyncmq.stores.base import BaseJobStore


class RedisJobStore(BaseJobStore):
    """
    A concrete implementation of `BaseJobStore` using Redis as the backend
    for storing and retrieving job data.

    Job data is stored as JSON strings in Redis keys, and the IDs of jobs
    belonging to a queue are tracked in a Redis Set.
    """
    def __init__(self, redis_url: str = "redis://localhost") -> None:
        """
        Initializes the RedisJobStore by establishing a connection to Redis.

        Args:
            redis_url: The connection URL for the Redis instance. Defaults to
                       "redis://localhost".
        """
        # Establish an asynchronous connection to the Redis server.
        # decode_responses=True ensures Redis returns strings instead of bytes.
        self.redis: redis.Redis = redis.from_url(redis_url, decode_responses=True)

    def _key(self, queue_name: str, job_id: str) -> str:
        """
        Generates the Redis key string used to store the data for a specific job.

        The key format is typically `jobs:{queue_name}:{job_id}`.

        Args:
            queue_name: The name of the queue the job belongs to.
            job_id: The unique identifier of the job.

        Returns:
            The formatted Redis key string.
        """
        # Format the key string using the queue name and job ID.
        return f"jobs:{queue_name}:{job_id}"

    def _set_key(self, queue_name: str) -> str:
        """
        Generates the Redis key string used for the Set that stores the IDs
        of all jobs belonging to a specific queue.

        The key format is typically `jobs:{queue_name}:ids`.

        Args:
            queue_name: The name of the queue.

        Returns:
            The formatted Redis key string for the Set.
        """
        # Format the key string for the Set using the queue name.
        return f"jobs:{queue_name}:ids"

    async def save(self, queue_name: str, job_id: str, data: Dict[str, Any]) -> None:
        """
        Asynchronously saves the data for a specific job in Redis.

        The job data dictionary is serialized to a JSON string and stored
        in a Redis key generated by `_key`. The job ID is also added to
        the Redis Set tracked by `_set_key` for the given queue.

        Args:
            queue_name: The name of the queue the job belongs to.
            job_id: The unique identifier of the job.
            data: The dictionary containing the job's data to be saved.
        """
        # Serialize the job data dictionary to a JSON string.
        job_data_json: str = json.dumps(data)
        # Store the JSON string in Redis using the generated job key.
        await self.redis.set(self._key(queue_name, job_id), job_data_json)
        # Add the job ID to the Set of job IDs for this queue.
        await self.redis.sadd(self._set_key(queue_name), job_id)

    async def load(self, queue_name: str, job_id: str) -> Optional[Dict[str, Any]]:
        """
        Asynchronously loads the data for a specific job from Redis by its ID.

        Retrieves the JSON string stored at the job's key, parses it into
        a dictionary, and returns it.

        Args:
            queue_name: The name of the queue the job belongs to.
            job_id: The unique identifier of the job.

        Returns:
            A dictionary containing the job's data if the key exists and
            contains valid JSON, otherwise None.
        """
        # Retrieve the raw JSON string from Redis using the generated job key.
        raw: Optional[str] = await self.redis.get(self._key(queue_name, job_id))
        # If raw data was retrieved, parse the JSON string into a dictionary.
        # Otherwise, return None.
        return json.loads(raw) if raw else None

    async def delete(self, queue_name: str, job_id: str) -> None:
        """
        Asynchronously deletes the data for a specific job from Redis.

        Removes the Redis key storing the job data and removes the job ID
        from the Set of job IDs for the queue.

        Args:
            queue_name: The name of the queue the job belongs to.
            job_id: The unique identifier of the job.
        """
        # Delete the Redis key that stores the job's data.
        await self.redis.delete(self._key(queue_name, job_id))
        # Remove the job ID from the Set of job IDs for this queue.
        await self.redis.srem(self._set_key(queue_name), job_id)

    async def all_jobs(self, queue_name: str) -> List[Dict[str, Any]]:
        """
        Asynchronously retrieves data for all jobs associated with a specific
        queue by fetching all IDs from the queue's Set and loading each job
        individually.

        Args:
            queue_name: The name of the queue.

        Returns:
            A list of dictionaries, where each dictionary is the data for a job
            in the specified queue. Jobs that cannot be loaded (e.g., key deleted
            between fetching ID and loading) are skipped.
        """
        # Get all job IDs stored in the Set for the queue.
        ids: List[str] = await self.redis.smembers(self._set_key(queue_name))
        # Use a list comprehension to load the data for each job ID.
        # Filter out any potential None results from load if a key vanished.
        jobs_data: List[Dict[str, Any]] = [
            job for job_id in ids if job_id and (job := await self.load(queue_name, job_id)) is not None
        ]
        return jobs_data

    async def jobs_by_status(self, queue_name: str, status: str) -> List[Dict[str, Any]]:
        """
        Asynchronously retrieves data for jobs in a specific queue that are
        currently in a given status by loading all jobs and filtering in memory.

        Note: This implementation is inefficient for large queues as it loads
        all jobs first. A more scalable backend would use Redis sorted sets
        or other structures to track jobs by status natively.

        Args:
            queue_name: The name of the queue.
            status: The status of the jobs to retrieve (e.g., "waiting", "active").

        Returns:
            A list of dictionaries, where each dictionary contains the data
            for a job matching the criteria.
        """
        # Retrieve data for all jobs in the queue.
        all_jobs: List[Dict[str, Any]] = await self.all_jobs(queue_name)
        # Filter the loaded jobs in memory based on their "status" field.
        filtered_jobs: List[Dict[str, Any]] = [
            job for job in all_jobs if job and job.get("status") == status
        ]
        return filtered_jobs
